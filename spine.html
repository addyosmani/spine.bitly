<p>&nbsp;</p>
<h1>A Short Re-Introduction To Backbone.js</h1>
<p>JavaScript developers wishing to add more structure to their client-side code often look for simpler ways to apply the popular MVC pattern to their applications. A number of solutions exist out there that can assist with this task (for example <a href="http://javascriptmvc.com/">JavascriptMVC</a> - which is perfect for larger projects), however to date Jeremy Ashkenas's <a href="http://documentcloud.github.com/backbone/">Backbone.js</a> has proven itself a worthy solution to achieving this, in particular when creating SPAs (single-page applications). </p>
<p>I've been quite an avid Backbone fan for some time and for any developers that have yet to try it out, I recommend it or newcommer <a href="http://maccman.github.com/spine/">Spine.js</a>, which we'll be looking at in more detail today.</p>
<p>To give you a quick summary on Backbone, which will help us compare it with Spine: data in it is represented through <em>models</em> (which can be created, destroyed and saved). Changes to the front-end/UI trigger a model to change and all of the <em>views</em> in your application that display the model's data are notified of the event, causing them to re-render. It is also quite agnostic in the JavaScript libraries it can be used with and is regularly combined with jQuery or zepto for DOM interaction.</p>
<p>The benefit tools like Spine and Backbone bring to the table is that the 'backbone' to your application's structure is all taken care of for you meaning that you can focus on improving the overall logic with your time. </p>
<p>For more on Backbone, feel free to read my article '<a href="http://addyosmani.com/blog/building-spas-jquerys-best-friends/">Building Single Page Applications with jQuery's Best Friends</a>' or check-out some of the excellent resources on their new wiki for more information.</p>
<p>Let us know look at <a href="http://maccman.github.com/spine/">Spine.js</a> - a new alternative to Backbone that's been getting quite a lot of interest lately.</p>
<p>&nbsp;</p>
<h1>An Introduction to Spine.js</h1>
<h3><strong>Back-story</strong></h3>
<p>A few months ago, I was approached by a rather passionate developer named Alex MacCaw to help provide guideance for a modern JaveScript web applications book he was working on. Much of the focus of the book ended up being on MVC and dependancy management (both of which really need a solid title on) but as it turns out, he ended up investing lot of the lessons he learned into creating<strong> Spine.js </strong>- a lightweight framework for building JavaScript web applications. </p>
<p>When Spine was first released, it received quite a number of <a href="http://news.ycombinator.com/item?id=2459143">mixed reviews</a>, however I believe in giving every new solution deserves a fair evaluation, which is why I wanted to write this post on Spine to answer questions that both I and other developers had about it. </p>
<h3><strong>So, what is Spine.js?</strong></h3>
<p>Spine is a lightweight framework that provides an MVC structure to your JavaScript applications with a focus on providing a more traditional literal inheritence model through classes and extension. It's based in many ways on Backbone's API so developers who have used Backbone before may find getting started a little easier than expected (however see the notes below for some fundamental differences). Spine also comes with baked in support for HTML5 localStorage and asynchronous server communication. </p>
<h3><strong>Spine's classes, models and views.</strong></h3>
<p>The official Spine documentation contains the most comprehensive break-down of it's features, which include support for validation, serialization, persistance, proxying and more.For the purpose of this post however, we're going to focus on the three big ones - namely: <em>classes</em>, <em>models</em> and <em>views</em>.</p>
<p><strong>Classes</strong></p>
<p>At the heart of Spine it's it's class implementation which uses en emulated version of Object.create to ensure that it's both dynamic and that properties can be resolved at runtime. Classes are relatively straight-forward to create as can be demonstrated in the following example:</p>
<pre>
var twitterClient = Spine.Class.create();
//or
var twitterClientWithArgs = Spine.Class.create({
testMessage: &quot;If it weren't for WebMD I would have never known what symptoms to mimic so I could get all these prescriptions from my doctor.&quot; 
});
</pre>
<p>Instantiating classes is then achieved using init(). Spine makes a decision to not use constructor functions as employing the &quot;new&quot; keyword can cause issues if left out when creating instances.</p>
<pre>
var twitterClient = Spine.Class.create({
 testMessage: &quot;Hello world&quot; 
});
var myclient = twitterClient.init();
</pre>
<p>Arguments that you pass to this are then passed to init(), the class's instantiation callback. Eg.</p>
<pre>
var twitterClient = Spine.Class.create({
 init:function(testMessage){
 this.testMessage = testMessage;
 } 
});
</pre>
<p><strong>Models</strong></p>
<p>In Spine, models are used for your application's data storage (models) as well as any logic associated with this data. This falls in line with the traditional idea of models in the MVC pattern and is also quite straight-forward to wrap your head around. Data that's associated with models is stored in memory under Model.records and models themselves can be created with the help of the Spine setup() function. </p>
<p>In the following example, we pass a model name and set of attributes  to setup():</p>
<pre>var Tweets = Spine.Model.setup(&quot;Tweet&quot;, [&quot;username&quot;,&quot;tweet_message&quot;]);</pre>
<p>Models are effectively also Spine classes so you're also able to extend them and include properties as follows:</p>
<pre>Tweets.include({
 toTweetString: function(){
 return(&quot;@&quot; + this.username + &quot; &quot; + this.tweet_message);
 }
});</pre>
<p>To create a model instance is then as trivial as using .init():</p>
<pre>var mytweets = Tweets.init({username: &quot;addyosmani&quot;, tweet_message: &quot;hai twitter&quot;});</pre>
<p>Spine and Backbone both have a viewing layer which consist of rendering templates to the DOM and this can be done using a variety of different templating solutions, which Alex will expand on shortly, along with other clarifications on his solution.</p>
<p>&nbsp;</p>
<p><strong>Controllers</strong></p>
<p>Think of controllers as the glue that holds everything together inside of your application. Similar to models, Spine's controllers extend Spine.Class and also inherit it's properties. By now you'll begin to see a pattern with the Spine syntax, but creating a controller is as simple as:</p>
<pre>var TweetController = Spine.Controller.create({
 init:function(){
 //initial logic on instantiation
 } 
<p>})</pre>
<p>Typically, you'll only add instance properties onto controllers and so you can easily pass them as the first argument to create(). Instantiation of controllers (as with other classes) is done by:</p>
<pre>var myTweetController = TweetController.init();</pre>
<p>Each controller also has an element associated with it, which can be passed down through an instance property called 'el'. This can also be set by passing it through via instantiation as follows:</p>
<pre>var myTweetController = TweetController.init({el: $('#tweets')});</pre>
<p>There are some interesting additional parameters that can be passed through to controllers, but the explanation above should suffice for understanding the basic workings of Spine's controllers.</p>
<p><strong>Quick Links</strong></p>
<p>Feel free to read more about <a href="http://maccman.github.com/spine/#h-classes">classes</a>, <a href="http://maccman.github.com/spine/#h-models">models</a> and <a href="http://maccman.github.com/spine/#h-controllers">controllers</a> in the official Spine docs.</p>
<p>&nbsp; </p>
<h3><strong>What are the main differences between Spine and Backbone?</strong></h3>
<p>Developers reading through the Backbone and Spine documentation may initially struggle o distinguish them, however after you get stuck in to using Spine in an actual project, you'll find that they do have some quite subtle differences which we'll go through below:</p>
<p>1) Backbone's <em>views</em> are what developers usually look at as traditional <em>controllers</em> and Backbone <em>controllers</em> assist with handling URL routing. Spine has recently added support for routing (something much needed) , but it's <em>controllers</em> are effectively the same concept as Backbone's <em>views. </em></p>
<p>2) In terms of inheritance, Backbone uses constructor functions and prototypes whilst Spine uses an emulated version of Object.create and a simulated class system for it's version - the idea of class, extension and inheritence is very much at the core of the Spine experience and this is something I personally found to be an interesting change from Backbone. Both approaches have properties which are correctly resolved at runtime but Alex is going to explain why he thinks his approach might be easier to understand in the next section.</p>
<p>3) I've noticed a few developers reading up on Spine cite the file-size differences as a reason to try it out, but just to comment on this further: In the Hacker news thread, Jeremy points out that the main difference is because Spine doesn't include the collection mapping, filtering, and aggregation functions Backbone comes with. Whilst this is true (again, I love Backbone dearly), the dependency on underscore is probably what Jeremy is referring to in his overall comparison. When it comes down to it, it will be your call as to whether you feel the KBs worth of difference is relevant to your application's load time or not.</p>
<p>&nbsp;</p>
<h1><strong>An Interview with Spine developer Alex MacCaw</strong></h1>
<p><strong>Could you tell us what inspired you to start writing Spine.js?</strong> </p>
<p>Well, I'd been playing around with own application frameworks for a while, specifically <a href="http://github.com/maccman/super">Super</a>, and had some idea of the real-word problems in web application design, and how to address them in a library.</p>

<p>
Whilst writing a chapter for my <a href="http://jswebapps.heroku.com/">O'Reilly JavaScript book</a>, I explored Backbone in more depth, and really liked what I saw. There were a few caveats to that which I'll address later, but all in all, Backbone's an excellent library. Spine was an endeavor to combine all I'd learnt so far with some of Backbone's concepts. </p>

<p>
<strong>When developers first look at Spine, they may be surprised at the number of similarities between it and Backbone.js. Could you take us through the advantages Spine has to offer? </strong></p>

<p>
Absolutely, and with good reason. Backbone's View (in Spine it's called a Controller) API is hard to improve on, so Spine implements something very similar. However, the similarities stop there. Spine has some rather different ideas concerning classes and models, although these may not be obvious from a quick glance. 
</p>

<p>
Before I go any further, I want to preface this with the message that I definitely don't want to turn this into an altercation between the two libraries, such as who's got what features and which is superior. Jeremy is very graceful when it comes to competition and I'm hoping, like Merb and Rails, both libraries can inspire each other and improve the ecosystem as a whole. With that said, I'll go through the things that, in my opinion, are Spine's strengths, and where the library differs with Backbone.  </p>

<p>
I've tried to keep Spine as slim as possible, and as a result the library's only about 500 lines, that's about 2k minified and compressed. However, Spine is easily extendable via a module interface, which is how features like routing are added, for example. This means you can choose exactly what you want to include in the page, keeping your application size down to an absolute minimum. Additionally, Spine doesn't require any third party libraries. </p>

<p>
Spine includes a class library, which is really useful for encapsulating your own code and modules. The library uses a pure prototypal inheritance based system, rather than copying properties, which means property lookup is dynamic. </p>

<p>
Spine does away with Collections, and puts records straight under models. This is in an effort to reduce code and simplify things. In fact, this is the message throughout the library. Simplification and clean code is at the core of Spine's philosophy. </p>

<p>
Spine includes lots controller shortcuts, such as element lookup and function proxying, as I found there was usually a fair amount of repetition there. </p>

<p>
Spine has different ideas when it comes to communicating with the server, namely de-coupling. What this means, is that servers are detached from the client, and aren't necessarily needed for clients to function properly. Apart from GET requests, clients are never waiting for response from the server. When a record is updated, for example, the client interface is updated, and then a request is send of to the server. All record ID generation is is done client side. </p>

<p>

This has the advantage that users have a completely non-blocking interface, they're never waiting for a slow server response for further interaction with the application. After they've updated a record, for example, they can go and update it again and again, without worrying about background requests. Traditionally, clients would block further input until any Ajax requests had been successfully propagated to the server; not so with Spine. This gives your clients a desktop like experience, every interaction is instantaneous. </p>

<p>
Lastly, I've done lots of work on the <a href="http://maccman.github.com/spine">documentation</a>. Using a new framework can be overwhelming at first, and I want to make it as easy as possible for developers to get started. Documentation is often neglected by developers, and I don't intend to make that mistake with Spine. In addition to the documentation, I've also put together some example applications, such as a simple <a href="http://github.com/maccman/spine.todos">todo list</a>, a <a href="http://github.com/maccman/spine.contacts">contact manager</a>, and a full-on realtime <a href="http://github.com/maccman/holla">group chat application</a>. </p>

<p>
<strong>I notice that Spine doesn't use the same concept of 'collections' that can be found in Backbone - how should developers who are used to Backbone's notion of models and collections approach this change?</strong></p>
<p>
I found that in the vast majority of cases, there was a direct one-to-one match between models and collections in my Backbone apps. It was quite the exception to have two collections to one model. It's for that reason I decided to forsake collections, and put records directly under models.</p>
<p>

That said, if you do need the equivalent of collections, it's as simple as subclassing the model. </p>

<p>
<strong>You mention that Spine uses a 'class' system. As you know, JavaScript has no native sense of traditional 'class', so how does your implementation work behind the scenes? Do you think client-side developers will be able to adjust to working with this easily?</strong></p>

<p>
I personally find some sort of class system in JavaScript very useful, and I therefore added one as a core component to Spine. JavaScript doesn't have a native class system, but it does have native inheritance through prototypes.</p> 

<p>
Traditionally, JavaScript class libraries have copied properties on sub-classes during inheritance. Even if they use some sort of prototypal inheritance, it'll only work for instance properties when using constructor functions. Static properties need to be copied manually to appear on sub-classes. This has the drawbacks that static properties aren't dynamic, and there's some overhead when first creating classes. </p>

<p>
Spine approaches the problem differently, using pure prototypal inheritance. This has only been possible recently due to browsers adding the `Object.create()` function to JavaScript.</p>

<p>
 Both static and instance properties are inherited prototypically, and are therefore dynamic. It's pretty neat, from an object you can see all the way up it's prototype tree, finally ending up at `Object`.</p>


<p>
The caveat to this approach is that instances can't be created with the `new` keyword, as classes aren't constructor functions. Instead, Spine has the `inst()` function. From a practical point of view, that's the only difference you'd make between traditional class implementations and Spine. </p>

<p>
<strong>I've been looking through the official documentation and I could be wrong, but is routing something Spine currently has support for (or will be trying to solve)?. If not, do you recommend integrating it with a solution like Ben Alman's hashchange plugin?</strong></p>
<p>
I've taken this opportunity to add routing to Spine. You'll find the module under <a href="http://maccman.github.com/spine/lib/spine.route.js">lib/spine.route.js</a></p>
<p>
I have also explained it in the documentation (<em>note that the demo we'll be looking at today uses Spine's new routing features).</em></p>

<p>
<strong>What kind of templating support does Spine have to offer? Backbone supports micro-templating via Underscore and a few other templating solutions (jQuery-tmpl etc). Is the same level of compatibility/support possible?</strong></p>
<p>
Spine leaves templating decisions up to you, it doesn't make any decisions when it comes to views. Personally, and in Spine's examples, I've used <a href="http://api.jquery.com/category/plugins/templates/">jQuery.tmpl</a>, but there are other good templating libraries out there you can use, like <a href="http://mustache.github.com/">Mustache</a> or Underscore's micro templating. 

<p>
<strong>I see that the project has already racked up quite some interest on GitHub. For those wondering how long you plan on maintaining spine, could you give us some insights on that? Is it a personal project or something you feel has the potential to grow into what Backbone has matured to since it got released?</strong></p>
<p>
Absolutely, the library is generating lots of interest, and my inbox is getting overloaded with feedback and suggestions. I'm definitely going to spend a lot of time supporting and extending Spine, particularly as it's the basis of a lot of the examples in my book, and the core for a startup idea I'm working on. Additionally there's some cool features in the pipeline for Spine, such as simple offline sync.</p>
<p> <strong>If developers are looking to get started with Spine today and would like to be pointed in the direction of some good examples of it's usage, what would you recommend they check out? </strong></p>

<p>
Well, you could certainly point people to the three main examples so far, <a href="http://github.com/maccman/spine.todos">Spine Todos</a>, <a href="http://github.com/maccman/spine.contacts">Spine Contacts</a> and <a href="http://github.com/maccman/holla">Holla</a>. Other than that, some examples I can think of: Twitter client, CMS, CRM, RSS reader. </p>
<p><strong>Great. By the way, is there a channel where developers wishing to have their questions about Spine answered can go check out? At the moment I think a lot of answers are being derived from looking at the source rather than asking you directly.</strong></p>
<p>Yes of course!. If it's a question, ask it on the <a href="https://groups.google.com/forum/?hl=en#%21forum/spinejs" target="_blank">Google Groups</a>. Otherwise, if it's a bug, <a href="https://github.com/maccman/spine/issues" target="_blank">open a ticket</a>. I'll try and respond to either as soon as I can. </p>
<p>
<strong>I was lucky enough to get a chance to see some of your book during some tech/content review sessions. Could you tell readers what they can expect to see in it and how Spine factors into your book's content for anyone wishing to learn more?</strong></p>
<p>
The aim of the book is to help you build the next generation of JavaScript web applications. The running theme throughout is structure, and the MVC pattern. The book will take you through all the steps involved in moving state to the client side, from templating and data binding to the actual deployment. A lot of the new HTML5 and CSS3 APIs are also covered, such as drag & drop file uploads and WebSockets. Finally, there's a full introduction to the Backbone, Spine and JavaScriptMVC frameworks. </p>
<p>
As you alluded to, a lot of the examples and concepts, especially in the chapters explaining models and controllers, are based on Spine. However, they'll be useful regardless of whether or not you end up using the library. </p>
<p>
Although the title hasn't quite been finalized yet (next day or so), the book will be on O'Reilly's Safari Rough Cuts in the next week or two. In the meantime you can check out the un-official website, see the full table of contents, and sign up to be notified when the book is released. </p>
<p><strong>Finally, what do you hope to add to Spine in the next few iterations? Are  there any clear areas that you would like to put more work into now that you've had an opportunity to sit back and review the first release?.</strong></p>
<p>Well, currently I'm building a mobile client with Spine - so expect to  see some features in that area. I'm thinking of adding support for some  simple transitions (via CSS) in the controller manager, and 'touch'  support to the list module. Lastly, I'm also working on a simple offline  data synchronization library for Spine, which I'll open source when  complete. All of these extensions will be implemented as modules, like  jQuery plugins. I'm trying to keep the core library as small and simple  as possible. Readers can 'watch' the repo on GitHub to find out as soon as updates are available.</p>
<h1>Tutorial: Building A Bit.ly Client With Spine.js</h1>
<p>Now that we've covered the basics, let's work on building something useful with Spine. </p>
<p>A lot of the time, when you're developing an SPA, you'll be consuming some external data (either your own or data supplied by an external API). You also might want to use routing to enable saving application state/bookmarking, possibly use localStorage and will of course need to handle the ajax requests to query whatever service is outputting your data.</p>
<p>With this in mind, today we're going to build a bit.ly client that allows you to easily:</p>
<ul>
  <li>create shortened URLs from inside your browser</li>
  <li>archive your bit.ly URLs so you can easily access them at any time</li>
  <li>provide you click statistics (just an additional 'view' so we can demonstrate routing)</li>
</ul>
<h3>&nbsp;</h3>
<h3>Pre-requisites</h3>
<p><strong>Create a bit.ly plugin</strong></p>
<p>Before we begin, we're going to need a convenient way to access bit.ly's services to first 1) shorten URLs and 2) access click statistics. Rather than keeping the ajax calls for this inline to our Spine code, I decided that a jQuery plugin would be a neater way of maintaining the logic outside of the app so it can easily be updated or re-used. Here's the bit.ly plugin that we put together:</p>
<p>&nbsp;</p>
<p><strong>Add support for store.js</strong></p>
<p>By default, Spine targets modern browsers and so it's currently implementation of localStorage doesn't work cross-browser if you wish to support those with different implements or which are older. </p>
<p>This however can be easily tackled by bringing in store.js (and it's dependancy json2.js). Below is the Spine file spine.model.local.js, which you can update to use store by commenting out the lines I've noted below and replacing them with the line that follows.</p>
<p>&nbsp;</p>
<pre>
Spine.Model.Local = {

  extended: function(){

    this.sync(this.proxy(this.saveLocal));

    this.fetch(this.proxy(this.loadLocal));

  },

    

  saveLocal: function(){

    var result = JSON.stringify(this);

    //localStorage[this.name] = result;

    store.set(this.name, result);

  },

  loadLocal: function(){

    //var result = localStorage[this.name];

    var result = store.get(this.name);

    if ( !result ) return;

    var result = JSON.parse(result);

    this.refresh(result);

  }

};
</pre>
<p><strong>jQuery templating</strong></p>
<p>Deciding which templating solution to use is often one of the nicest parts of using either Spine or Backbone as they both support a multiude of different solutions (underscore's micro-templating, mustache.js and so on). Today we're going to use jQuery's tmpl plugin to render our shortened URL entries and click statistics using templates. </p>
<p>&nbsp;</p>
<h2>The application </h2><p>
Alex was kind enough to refactor the app to follow some of Spine's best practices so let's summarize the structure of our application beyond the pre-requisites. We'll need:</p>
<ul>
  <li> A model to represent the data being stored in each shortened URL entry (Url model)</li>
  <li> A controller to represent individual entries and the actions that can be done with them (exports.Urls)</li>
  <li> A controller to represent the view for adding in new shortened bit.ly entries (exports.UrlsList)</li>
  <li> A controller to represent the view for click statistics of a given entry (exports.Stats)</li>
  <li> A generic application controller that will amongst other things, handle general routing (exports.UrlApp)</li>
</ul>
<p>We've opted to use jQuery in today's tutorial application as we're using it for both templating and plugin structure, however, Spine works just as well with zepto or vanilla JavaScript. Let's now take a look at the code for our app:</p>
<p><strong>Initial caching and a simple jQuery plugin for toggling the display of content</strong></p>
<pre>
var exports = this;
$.fn.toggleDisplay = function(bool){
    if ( typeof bool == "undefined" ) {
      bool = !$(this).filter(":first:visible")[0];
    }
    return $(this)[bool ? "show" : "hide"]();
};
</pre>
<p><strong><br />
Url model:</strong></p>
<pre>var Url = Spine.Model.setup("Url", ["short_url", "long_url", "stats"]);

Url.extend(Spine.Model.Local);

Url.include({
  validate: function(){
    if ( !this.long_url )
      return "long_url required"
      
    if ( !this.long_url.match(/:\/\//))
      this.long_url = "http://" + this.long_url
  },
  
  fetchUrl: function(){
    if ( !this.short_url )
      $.bitly(this.long_url, this.proxy(function(result){
        this.updateAttributes({short_url: result});
      }));
  },
  
  fetchStats: function(){
    if ( !this.short_url ) return;
    $.bitly.stats(this.short_url, this.proxy(function(result){
      this.updateAttributes({stats: result});
    }));
  }
});

Url.bind("create", function(rec){
  rec.fetchUrl();
});</pre></p>
<p><br />
  <strong>exports.Urls controller:</strong></p>

<pre>
  exports.Urls = Spine.Controller.create({
    events: {
      "click .destroy": "destroy",
      "click .toggleStats": "toggleStats"
    },
    
    proxied: ["render", "remove"],

    template: function(items){
      return $("#urlTemplate").tmpl(items);
    },
    
    init: function(){
      this.item.bind("update",  this.render);
      this.item.bind("destroy", this.remove);
    },
    
    render: function(){
      this.el.html(this.template(this.item));
      return this;
    },
    
    toggleStats: function(){
      this.navigate("/stats", this.item.id, true);
    },
    
    remove: function(){
      this.el.remove();
    },
    
    destroy: function(){
      this.item.destroy();
    }
  });</pre>
<p><strong><br />
  exports.UrlsList controller:</strong></p>
<pre>exports.UrlsList = Spine.Controller.create({
    elements: {
      ".items": "items",
      "form":   "form",
      "input":  "input"
    },
    
    events: {
      "submit form": "create",
    },
    
    proxied: ["render", "addAll", "addOne"],
    
    init: function(){
      Url.bind("create",  this.addOne);
      Url.bind("refresh", this.addAll);
    },
    
    addOne: function(url){
      var view = Urls.init({item: url});
      this.items.append(view.render().el);
    },
    
    addAll: function(){
      Url.each(this.addOne);
    },
        
    create: function(e){
      e.preventDefault();
      var value = this.input.val();
      
      if (value)
        Url.create({long_url: value});

      this.input.val("");
      this.input.focus();
    }
  });</pre>
<p><strong><br />
  exports.Stats controller:</strong></p>
<pre>
  exports.Stats = Spine.Controller.create({
    events: {
      "click .back": "back"
    },
    
    proxied: ["change", "render"],
    
    init: function(){
      Url.bind("update", this.render);
    },
    
    template: function(items){
      return $("#statsTemplate").tmpl(items);
    },
    
    render: function(){
      if ( !this.item ) return;
      this.el.html(this.template(this.item));
    },
    
    change: function(item){
      this.item = item;
      this.navigate("/stats", item.id);
      this.item.fetchStats();
      this.render();
      this.active();
    },
    
    back: function(){
      this.navigate("/list", true);
    }
  });
</pre>
<p><strong><br />
  exports.UrlApp controller:</strong></p>
<pre>  exports.UrlApp = Spine.Controller.create({
    el: $("body"),
    
    elements: {
      "#urls": "urlsEl",
      "#stats": "statsEl"
    },
    
    init: function(){
      this.list = UrlsList.init({el: this.urlsEl});
      this.stats = Stats.init({el: this.statsEl});
      
      this.manager = Spine.Controller.Manager.init();
      this.manager.addAll(this.list, this.stats);
      
      this.routes({
        "": function(){ this.list.active() },
        "/list": function(){ this.list.active() },
        "/stats/:id": function(id){ this.stats.change(Url.find(id)) }
      });
      
      Url.fetch();
      Spine.Route.setup();
    }
  });</pre>
<p><br />
  Finally, we call the following to complete the initialization of our 'app' controller:</p>
<pre>exports.App = UrlApp.init();</pre>
<p><strong>Application Index/HTML:</strong></p>
<p>Below I've opted to use LABjs for dependency management, however you can easily switch this out for whatever script loader you personally prefer using.</p>
<pre>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;css/application.css&quot; type=&quot;text/css&quot; charset=&quot;utf-8&quot;&gt;

  &lt;script src=&quot;lib/LAB.min.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
  &lt;script type=&quot;text/javascript&quot;&gt;
	$LAB
	.script(&quot;lib/json.js&quot;)
	.script(&quot;lib/jquery.js&quot;)
	.script(&quot;lib/jquery.tmpl.js&quot;)
	.script(&quot;lib/jquery.bitly.js&quot;)
	.script(&quot;lib/store.min.js&quot;)
	.script(&quot;lib/spine.js&quot;)
	.script(&quot;lib/spine.model.local.js&quot;)
	.script(&quot;lib/spine.controller.manager.js&quot;)
	.script(&quot;lib/spine.route.js&quot;)
	.script(&quot;app/models/url.js&quot;)
	.script(&quot;app/application.js&quot;);
  &lt;/script&gt;
  
  &lt;script type=&quot;text/x-jquery-tmpl&quot; id=&quot;urlTemplate&quot;&gt;
    &lt;div class=&quot;item&quot;&gt;
      &lt;div class=&quot;show&quot;&gt;
        &lt;span class=&quot;short&quot;&gt;
          ${long_url}
        &lt;/span&gt;
      
        &lt;span class=&quot;long&quot;&gt;
          {{if short_url}}
            &lt;a href=&quot;${short_url}&quot;&gt;${short_url}&lt;/a&gt;
          {{else}}
            Generating...
          {{/if}}
        &lt;/span&gt;
      
        &lt;a class=&quot;toggleStats&quot;&gt;&lt;/a&gt;
        &lt;a class=&quot;destroy&quot;&gt;&lt;/a&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/script&gt;  
  
  &lt;script type=&quot;text/x-jquery-tmpl&quot; id=&quot;statsTemplate&quot;&gt;  
    &lt;div class=&quot;stats&quot;&gt;
      &lt;a class=&quot;back&quot;&gt;Back&lt;/a&gt;
    
      &lt;h1&gt;Click Statistics&lt;/h1&gt;
      &lt;h1 class=&quot;longUrl&quot;&gt;${long_url}&lt;/h1&gt;
      
      &lt;p&gt;Short URL: 
        {{if short_url}}
          &lt;a href=&quot;${short_url}&quot;&gt;${short_url}&lt;/a&gt;
        {{else}}
          Generating...
        {{/if}}
      &lt;/p&gt;
    
      {{if stats}}
        &lt;p&gt;Global clicks: ${stats.global_clicks}&lt;/p&gt;
        &lt;p&gt;User clicks: ${stats.user_clicks}&lt;/p&gt;
      {{else}}
        Fetching...
      {{/if}}
    &lt;/div&gt;
  &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id=&quot;views&quot;&gt;
    &lt;div id=&quot;urls&quot;&gt;
      &lt;h1&gt;Bit.ly Client&lt;/h1&gt;
      
      &lt;form&gt;
        &lt;input type=&quot;text&quot; placeholder=&quot;Enter a URL&quot;&gt;
      &lt;/form&gt;
      
      &lt;div class=&quot;items&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
    
    &lt;div id=&quot;stats&quot;&gt;
    &lt;/div&gt;
  &lt;/div&gt;

&lt;/body&gt;
&lt;/html&gt;</pre>
<p><br />
  and that's it!. To download the sources for today's tutorial or try our a live demo, please click on one of the buttons below.</p>
<p><strong>Notes:</strong></p>
<ul>
  <li> Although Spine currently works fine in all modern browsers (Chrome, Firefox, Opera etc), it does currently have known issues with IE which Alex is actively working on ironing out. Once Spine is fully cross-browser compatible, it *should* be at a point where you can use it to create production level applications as long as you have a solid testing strategy in place, however until then, feel free to play around with it from a learning perspective. </li>
  <li> When approaching bookmarking and routing in Spine, remember that if you wish to preserve unique 'views' for content (eg. one view for #ui/dashboard and another completely different one for #ui/stats), you'll be responsible for performing the toggle/show/hide of views you don't wish to see on the screen simultaneously as there isn't a baked in way to handle this. Fortunately, this is very straight-forward to achieve using your JS library of choice or simply vanilla JavaScript.</li>
</ul>
<p><strong>Conclusions</strong></p>
<p>I found working with Spine a nice &quot;alternative&quot; experience to what I'm used to with Backbone. The documentation is relatively straight-forward to study and if you're interested in playing around with Spine further, I recommend forking one of the sample apps listed to see just how each piece correlates with something already functional and complete. </p>
<p>Thanks for reading. If you found this post useful, please help spread the knowledge by clicking on the <em>retweet</em> or <em>like </em>buttons below.</p>
